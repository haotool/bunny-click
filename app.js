{
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Bunny Click",
        "alternateName": "Bunny Click",
        "description": "Bunny Click 是一款免費的線上點擊遊戲，支援 PWA 離線遊戲、TPS 計算功能。粉色×天藍配色主題，支援手機、平板、電腦多平台使用。",
        "url": "https://haotool.org/bunny-click/",
        "applicationCategory": "Game",
        "applicationSubCategory": "CasualGame",
        "operatingSystem": "Any",
        "browserRequirements": "Requires JavaScript. HTML5 compatible browser.",
        "softwareVersion": "7.2.0",
        "dateCreated": "2024-01-01",
        "dateModified": "2025-08-16",
        "datePublished": "2024-01-01",
        "inLanguage": "zh-TW",
        "isAccessibleForFree": true,
        "author": {
          "@type": "Person",
          "name": "s123104",
          "identifier": "s123104"
        },
        "publisher": {
          "@type": "Person",
          "name": "s123104"
        },
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "TWD",
          "availability": "https://schema.org/InStock",
          "category": "Free"
        },
        "screenshot": "https://haotool.org/bunny-click/icons/bunny-click.png",
        "image": "https://haotool.org/bunny-click/icons/bunny-click.png",
        "thumbnailUrl": "https://haotool.org/bunny-click/icons/icon-192x192.png",
        "featureList": [
          "TPS (每秒點擊次數) 計算",
          "PWA 離線遊戲支援",
          "多平台相容 (手機、平板、電腦)",
          "粉色×天藍漸層配色主題",
          "即時統計與記錄",
          "無需註冊或登入",
          "支援觸控和滑鼠操作",
          "Service Worker 快取機制"
        ],
        "requirements": "JavaScript enabled browser, HTML5 support",
        "gamePlatform": ["Web Browser", "Mobile", "Desktop", "Progressive Web App"],
        "genre": ["Casual", "Arcade", "Clicker"],
        "playMode": "SinglePlayer",
        "accessibilityFeature": [
          "keyboard navigation",
          "touch support",
          "screen reader compatible"
        ],
        "keywords": "點擊遊戲, Bunny Click, Bunny Click, 免費遊戲, PWA遊戲, 線上遊戲, TPS計算, 點擊速度, 手機遊戲, 離線遊戲",
        "mainEntity": {
          "@type": "Game",
          "name": "Bunny Click",
          "description": "測試你的點擊速度！計算每秒點擊次數 (TPS)，挑戰你的極限。",
          "genre": "Casual Gaming",
          "playMode": "SinglePlayer",
          "gameItem": {
            "@type": "Thing",
            "name": "點擊按鈕",
            "description": "主要遊戲互動元素"
          }
        },
        "potentialAction": {
          "@type": "PlayAction",
          "target": "https://haotool.org/bunny-click/",
          "name": "開始遊戲"
        }
      }
{
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [
          {
            "@type": "Question",
            "name": "Bunny Click 是什麼？",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "Bunny Click 是一款免費的線上點擊遊戲，採用 PWA 技術支援離線遊戲體驗。提供精確的 TPS (每秒點擊次數) 計算系統，讓您測試和提升點擊速度。"
            }
          },
          {
            "@type": "Question",
            "name": "如何開始遊戲？",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "開啟瀏覽器訪問 Bunny Click 網站，點擊「單人挑戰模式」或「雙人對戰模式」即可立即開始遊戲，無需下載安裝任何軟體。"
            }
          },
          {
            "@type": "Question",
            "name": "什麼是 TPS 計算？",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "TPS 是 Taps Per Second (每秒點擊次數) 的縮寫，Bunny Click 提供精確的 TPS 計算系統，即時顯示您的點擊速度表現，幫助您挑戰極限。"
            }
          },
          {
            "@type": "Question",
            "name": "支援哪些裝置？",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "Bunny Click 完美支援手機、平板、電腦等多種裝置，採用響應式設計確保在任何螢幕尺寸下都能提供最佳遊戲體驗。"
            }
          },
          {
            "@type": "Question",
            "name": "什麼是 PWA 離線功能？",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "PWA (Progressive Web App) 技術讓 Bunny Click 支援離線遊戲，即使沒有網路連線也能繼續遊戲，並可安裝到裝置主畫面像原生 App 一樣使用。"
            }
          },
          {
            "@type": "Question",
            "name": "遊戲完全免費嗎？",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "是的，Bunny Click 完全免費，無需註冊或登入，無隱藏費用，也沒有廣告干擾，讓您專注享受純粹的點擊樂趣。"
            }
          },
          {
            "@type": "Question",
            "name": "如何提升點擊速度？",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "建議使用食指快速點擊，保持手部放鬆，找到節奏感。練習時可從短時間開始，逐漸增加持續時間，定期查看 TPS 統計來追蹤進步。"
            }
          },
          {
            "@type": "Question",
            "name": "雙人對戰如何進行？",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "選擇雙人對戰模式，兩位玩家可在同一螢幕上競賽，左右分屏設計，即時顯示雙方點擊數和 TPS，增加競爭樂趣和互動性。"
            }
          },
          {
            "@type": "Question",
            "name": "有排行榜功能嗎？",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "有的，Bunny Click 提供本地排行榜功能，記錄您的最佳成績，支援單人模式和雙人對戰模式的分別排名，激勵您不斷挑戰更高分數。"
            }
          },
          {
            "@type": "Question",
            "name": "資料會被保存嗎？",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "所有遊戲記錄和設定都保存在您的裝置本地，確保隱私安全。即使離線也能查看歷史成績，PWA 技術確保資料不會遺失。"
            }
          }
        ]
      }
{
        "@context": "https://schema.org",
        "@type": "VideoGame",
        "name": "Bunny Click - 點擊樂趣遊戲",
        "alternateName": ["Bunny Click", "Bunny Click", "點擊遊戲"],
        "description": "免費的線上點擊速度測試遊戲，支援 PWA 技術可離線遊戲。測試您的點擊速度，計算 TPS (每秒點擊次數)，享受粉色×天藍的美麗配色。",
        "url": "https://haotool.org/bunny-click/",
        "image": "https://haotool.org/bunny-click/icons/bunny-click.png",
        "genre": ["Casual", "Arcade", "Clicker Game"],
        "playMode": "SinglePlayer",
        "applicationCategory": "Game",
        "gamePlatform": ["PC", "Mobile", "Web Browser", "PWA"],
        "operatingSystem": "Cross-platform",
        "processorRequirements": "Any modern processor",
        "memoryRequirements": "Minimal RAM required",
        "storageRequirements": "< 1MB (PWA cache)",
        "datePublished": "2024-01-01",
        "dateModified": "2025-08-16",
        "version": "7.2.0",
        "inLanguage": "zh-TW",
        "isAccessibleForFree": true,
        "author": {
          "@type": "Person",
          "name": "s123104"
        },
        "publisher": {
          "@type": "Person",
          "name": "s123104"
        },
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "TWD",
          "availability": "https://schema.org/InStock"
        },
        "aggregateRating": {
          "@type": "AggregateRating",
          "ratingValue": "4.8",
          "ratingCount": "1",
          "bestRating": "5",
          "worstRating": "1"
        },
        "contentRating": "Everyone",
        "keywords": "點擊遊戲, 速度測試, TPS計算, PWA遊戲, 免費遊戲",
        "mainEntityOfPage": "https://haotool.org/bunny-click/"
      }
{
        "@context": "https://schema.org",
        "@type": "HowTo",
        "name": "如何玩 Bunny Click 點擊遊戲",
        "description": "學習如何使用 Bunny Click 進行點擊速度測試和提升 TPS 表現的完整指南",
        "totalTime": "PT2M",
        "estimatedCost": {
          "@type": "MonetaryAmount",
          "currency": "TWD",
          "value": "0"
        },
        "supply": [
          {
            "@type": "HowToSupply",
            "name": "任何支援瀏覽器的裝置"
          }
        ],
        "tool": [
          {
            "@type": "HowToTool",
            "name": "滑鼠、觸控螢幕或鍵盤"
          }
        ],
        "step": [
          {
            "@type": "HowToStep",
            "name": "開始遊戲",
            "text": "開啟瀏覽器訪問 Bunny Click 網站，選擇單人挑戰模式或雙人對戰模式開始遊戲",
            "url": "https://haotool.org/bunny-click/#start",
            "image": "https://haotool.org/bunny-click/icons/bunny-click.png"
          },
          {
            "@type": "HowToStep",
            "name": "進行點擊測試",
            "text": "快速點擊遊戲區域，系統會即時計算並顯示您的 TPS (每秒點擊次數) 表現",
            "url": "https://haotool.org/bunny-click/#gameplay"
          },
          {
            "@type": "HowToStep",
            "name": "查看成績",
            "text": "遊戲結束後查看詳細統計數據，包括總點擊數、平均 TPS 和最高 TPS 記錄",
            "url": "https://haotool.org/bunny-click/#results"
          },
          {
            "@type": "HowToStep",
            "name": "提升技巧",
            "text": "使用食指快速點擊，保持手部放鬆，找到節奏感。定期練習以提升點擊速度",
            "url": "https://haotool.org/bunny-click/#tips"
          }
        ]
      }
(function () {
        const noop = () => {};
        ['log', 'warn', 'error', 'info', 'debug', 'time', 'timeEnd'].forEach(m => {
          try {
            console[m] = noop;
          } catch (e) {}
        });
      })();

      // ===== 版本管理 =====
      const APP_VERSION = '7.1.4';
      const SW_ENHANCED_VERSION = 'bunny-click-enhanced-v1.1.0';

      // 更新版本號顯示
      function updateVersionDisplay() {
        const versionDisplay = document.getElementById('versionDisplay');
        if (versionDisplay) {
          versionDisplay.textContent = `v${APP_VERSION}`;
        }
      }

      // 當前版本的所有快取名稱模式
      const CURRENT_CACHE_PATTERNS = [
        `bunny-click-v${APP_VERSION}`,
        `${SW_ENHANCED_VERSION}-app-shell`,
        `${SW_ENHANCED_VERSION}-static`,
        `${SW_ENHANCED_VERSION}-dynamic`,
        `${SW_ENHANCED_VERSION}-images`,
      ];

      // ===== 鼓勵文字系統 =====
      const ENCOURAGEMENT_MESSAGES = [
        // 1-5 TPS: 新手鼓勵
        { minTPS: 1, maxTPS: 2, message: '不錯的開始！手指正在熱身中 🔥' },
        { minTPS: 2, maxTPS: 3, message: '感覺到節奏了嗎？繼續保持！ 🎵' },
        { minTPS: 3, maxTPS: 4, message: '你的手指開始跳舞了！💃' },
        { minTPS: 4, maxTPS: 5, message: '穩定的節奏，就像心跳一樣！❤️' },
        { minTPS: 5, maxTPS: 6, message: '手指靈活度 +1！繼續加油！✨' },

        // 6-15 TPS: 進階鼓勵
        { minTPS: 6, maxTPS: 8, message: '哇！你的手指有魔法嗎？🪄' },
        { minTPS: 8, maxTPS: 10, message: '這速度讓螢幕都開始發燙了！🔥' },
        { minTPS: 10, maxTPS: 12, message: '手指變成閃電了！⚡' },
        { minTPS: 12, maxTPS: 15, message: '你是點擊界的鋼琴家！🎹' },
        { minTPS: 15, maxTPS: 18, message: '手速快到模糊了！👻' },

        // 16-30 TPS: 高手級鼓勵
        { minTPS: 18, maxTPS: 20, message: '這是人類的極限嗎？！🚀' },
        { minTPS: 20, maxTPS: 22, message: '手指已經突破音速！💨' },
        { minTPS: 22, maxTPS: 25, message: '你的手指是渦輪增壓的嗎？🏎️' },
        { minTPS: 25, maxTPS: 28, message: '連蜂鳥都自嘆不如！🐦' },
        { minTPS: 28, maxTPS: 30, message: '手指變成光速了！💫' },

        // 31-50 TPS: 超人級鼓勵
        { minTPS: 30, maxTPS: 35, message: '你確定不是機器人嗎？🤖' },
        { minTPS: 35, maxTPS: 40, message: '手指已經進入超次元空間！🌌' },
        { minTPS: 40, maxTPS: 45, message: '這速度連閃電都追不上！⚡⚡' },
        { minTPS: 45, maxTPS: 50, message: '你的手指違反了物理定律！🧪' },
        { minTPS: 50, maxTPS: 55, message: '手指已經超越時空限制！⏰' },

        // 51-70 TPS: 神級鼓勵
        { minTPS: 55, maxTPS: 60, message: '這是傳說中的神之手速！👑' },
        { minTPS: 60, maxTPS: 65, message: '你的手指擁有量子糾纏能力！⚛️' },
        { minTPS: 65, maxTPS: 70, message: '手指已經達到宇宙級頻率！🌟' },
        { minTPS: 70, maxTPS: 75, message: '連時間都為你的速度停止！⏸️' },
        { minTPS: 75, maxTPS: 80, message: '你的手指創造了新的維度！🔮' },

        // 81-100 TPS: 終極鼓勵
        { minTPS: 80, maxTPS: 85, message: '手指已經成為純能量體！💥' },
        { minTPS: 85, maxTPS: 90, message: '你重新定義了「快」這個字！📚' },
        { minTPS: 90, maxTPS: 95, message: '手指速度已經無法用科學解釋！🔬' },
        { minTPS: 95, maxTPS: 100, message: '你就是點擊宇宙的創造者！🌍' },
        { minTPS: 100, maxTPS: Infinity, message: '傳說中的點擊之神降臨！👼' },
      ];

      // 獲取對應 TPS 的鼓勵文字
      function getEncouragementMessage(tps) {
        for (const msg of ENCOURAGEMENT_MESSAGES) {
          if (tps >= msg.minTPS && tps < msg.maxTPS) {
            return msg.message;
          }
        }
        return ENCOURAGEMENT_MESSAGES[ENCOURAGEMENT_MESSAGES.length - 1].message;
      }

      // 版本檢測和自動更新
      async function checkForUpdates() {
        if ('serviceWorker' in navigator) {
          try {
            const registration = await navigator.serviceWorker.ready;
            if (registration.active) {
              // 檢查本地存儲的版本
              const storedVersion = localStorage.getItem('app_version');
              if (storedVersion && storedVersion !== APP_VERSION) {
                console.log(`版本更新：${storedVersion} → ${APP_VERSION}`);

                // 顯示版本更新提示
                showVersionUpdateToast(storedVersion, APP_VERSION);

                // 清除舊版本快取
                if ('caches' in window) {
                  const cacheNames = await caches.keys();
                  await Promise.all(
                    cacheNames.map(cacheName => {
                      // 檢查是否為當前版本的快取
                      const isCurrentVersion = CURRENT_CACHE_PATTERNS.includes(cacheName);

                      if (!isCurrentVersion) {
                        console.log(`清除舊快取: ${cacheName}`);
                        return caches.delete(cacheName);
                      } else {
                        console.log(`保留當前快取: ${cacheName}`);
                      }
                    })
                  );
                }
                // 更新版本號
                localStorage.setItem('app_version', APP_VERSION);

                // 延遲重新載入，讓用戶看到更新提示
                setTimeout(() => {
                  window.location.reload();
                }, 3000);
                return;
              }
              // 首次安裝或版本相同
              localStorage.setItem('app_version', APP_VERSION);
            }
          } catch (error) {
            console.log('版本檢測失敗:', error);
          }
        }
      }

      // 顯示版本更新提示
      function showVersionUpdateToast(oldVersion, newVersion) {
        const toast = document.createElement('div');
        toast.className = 'version-update-toast';
        toast.innerHTML = `
          <div class="toast-content">
            <div class="toast-icon">
              <span class="material-symbols-rounded" style="color: #ffd700;">celebration</span>
            </div>
            <div class="toast-text">
              <div class="toast-title">版本更新檢測到！</div>
              <div class="toast-subtitle">從 v${oldVersion} 更新至 v${newVersion}</div>
            </div>
            <button class="toast-close" onclick="this.parentElement.parentElement.remove()">×</button>
          </div>
        `;

        document.body.appendChild(toast);

        // 3秒後自動消失
        setTimeout(() => {
          if (toast.parentElement) {
            toast.remove();
          }
        }, 3000);
      }

      // ===== 遊戲狀態 =====
      const GameState = {
        isPlaying: false,
        hasStarted: false, // 是否已經開始計時
        mode: 'single',
        timeLeft: 30,
        scores: { single: 0, player1: 0, player2: 0 },
        settings: {
          soundEnabled: true,
          vibrationEnabled: true,
          gameDuration: 30,
          rippleEnabled: true,
          lightningEnabled: true,
          showTps: true,
        },
        pointers: new Map(),
        activePointers: new Map(),
        lastTapTime: { single: 0, player1: 0, player2: 0 },
        tpsEMA: { single: 0, player1: 0, player2: 0 },
        tapTimestamps: { single: [], player1: [], player2: [] },
        tpsUpdateInterval: null,
        maxTPS: { single: 0, player1: 0, player2: 0 },
        tapQueues: [],
        inputLockUntil: 0,
        ultraSpeedTimeout: null,
        ultraSpeedTimeout1: null,
        ultraSpeedTimeout2: null,
      };

      const SPEED_STEP = 0.5; // 每 0.5 TPS 一級，總共 10 級（越高越炫）
      const tpsToLevel = tps => Math.max(1, Math.min(10, Math.floor(tps / SPEED_STEP) + 1));

      // 正確的 TPS 計算函數 - 基於滑動窗口
      function calculateRealTPS(playerId) {
        const now = performance.now();
        const timestamps = GameState.tapTimestamps[playerId];

        // 清除超過1秒的舊記錄
        while (timestamps.length > 0 && now - timestamps[0] > 1000) {
          timestamps.shift();
        }

        return timestamps.length;
      }

      // 更新所有玩家的 TPS 顯示
      function updateAllTPS() {
        if (!GameState.settings.showTps || !GameState.isPlaying) return;

        const players = GameState.mode === 'single' ? ['single'] : ['player1', 'player2'];

        players.forEach(playerId => {
          const realTPS = calculateRealTPS(playerId);
          GameState.tpsEMA[playerId] = realTPS; // 直接使用真實 TPS，不需要 EMA 平滑

          // 記錄最高 TPS 峰值
          if (realTPS > GameState.maxTPS[playerId]) {
            GameState.maxTPS[playerId] = realTPS;
          }
        });

        uiManager.updateTpsHUD();
      }
      let fxWorker = null,
        fxCanvas = null,
        offscreen = null,
        dpr = 1;
      const isLowPower =
        ('connection' in navigator && navigator.connection && navigator.connection.saveData) ||
        false;

      // ===== FX Worker 初始化 =====
      function setupWorker() {
        // 防止重複初始化
        if (offscreen || fxWorker) {
          console.log('Worker already initialized, skipping...');
          return;
        }

        fxCanvas = document.getElementById('fxCanvas');
        if (!fxCanvas) {
          console.error('Canvas initialization failed');
          return;
        }

        dpr = Math.min(isLowPower ? 1.25 : 1.6, window.devicePixelRatio || 1);

        try {
          if ('OffscreenCanvas' in window && fxCanvas.transferControlToOffscreen) {
            offscreen = fxCanvas.transferControlToOffscreen();
            fxWorker = new Worker('./fx.worker.js', { type: 'module' });
            fxWorker.postMessage({ type: 'init', canvas: offscreen, dpr, lowPower: isLowPower }, [
              offscreen,
            ]);
          } else {
            fxWorker = new Worker('./fx.worker.js', { type: 'module' });
            fxWorker.postMessage({ type: 'init-fallback' }, []);
          }
          resizeFx();
          sendSettingsToWorker();
        } catch (error) {
          console.error('Worker setup failed: [ERROR FILTERED]');
          // 回退到非 OffscreenCanvas 模式
          if (!fxWorker) {
            fxWorker = new Worker('./fx.worker.js', { type: 'module' });
            fxWorker.postMessage({ type: 'init-fallback' }, []);
            resizeFx();
            sendSettingsToWorker();
          }
        }
      }
      function resizeFx() {
        const r = fxCanvas.getBoundingClientRect();
        if (offscreen) {
          fxWorker.postMessage({
            type: 'resize',
            width: r.width,
            height: r.height,
            dpr,
          });
        } else {
          fxCanvas.width = Math.floor(r.width * dpr);
          fxCanvas.height = Math.floor(r.height * dpr);
          fxWorker.postMessage({
            type: 'resize',
            width: r.width,
            height: r.height,
            dpr,
          });
        }
      }
      window.addEventListener('resize', resizeFx);
      function sendSettingsToWorker() {
        fxWorker &&
          fxWorker.postMessage({
            type: 'config',
            rippleEnabled: GameState.settings.rippleEnabled,
            lightningEnabled: GameState.settings.lightningEnabled,
          });
      }

      // ===== 音效管理 =====
      class AdvancedAudioManager {
        constructor() {
          this.audioContext = null;
          this.masterGain = null;
          this.sounds = {};
          this.isInitialized = false;
        }
        async init() {
          if (this.isInitialized) return;
          try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
              latencyHint: 'interactive',
              sampleRate: 44100,
            });
            this.masterGain = this.audioContext.createGain();
            this.masterGain.connect(this.audioContext.destination);
            if (this.audioContext.state === 'suspended') await this.audioContext.resume();
            const sr = this.audioContext.sampleRate;
            this.sounds.tap = this.renderTap(sr);
            this.sounds.countdown = this.renderBeep(sr);
            this.sounds.victory = this.renderVictory(sr);
            this.sounds.firework = this.renderFirework(sr);
            this.isInitialized = true;
          } catch (e) {}
        }
        renderTap(sr) {
          const n = Math.floor(sr * 0.06),
            b = this.audioContext.createBuffer(1, n, sr),
            d = b.getChannelData(0);
          for (let i = 0; i < n; i++) {
            const t = i / sr;
            d[i] = Math.sin(2 * Math.PI * (900 - 400 * t) * t) * Math.exp(-t * 28) * 0.35;
          }
          return b;
        }
        renderBeep(sr) {
          const n = Math.floor(sr * 0.18),
            b = this.audioContext.createBuffer(1, n, sr),
            d = b.getChannelData(0);
          for (let i = 0; i < n; i++) {
            const t = i / sr;
            d[i] = Math.sin(2 * Math.PI * 1000 * t) * Math.exp(-t * 12) * 0.4;
          }
          return b;
        }
        renderVictory(sr) {
          const n = Math.floor(sr * 0.9),
            b = this.audioContext.createBuffer(2, n, sr);
          const m = [261.63, 329.63, 392, 523.25, 659.25, 784];
          for (let c = 0; c < 2; c++) {
            const d = b.getChannelData(c);
            for (let i = 0; i < n; i++) {
              const t = i / sr,
                idx = Math.floor(t * 6) % m.length;
              d[i] = Math.sin(2 * Math.PI * m[idx] * t) * Math.max(0, 1 - t) * 0.24;
            }
          }
          return b;
        }
        renderFirework(sr) {
          const n = Math.floor(sr * 0.35),
            b = this.audioContext.createBuffer(2, n, sr);
          for (let c = 0; c < 2; c++) {
            const d = b.getChannelData(c);
            for (let i = 0; i < n; i++) {
              const t = i / sr;
              d[i] = (Math.random() - 0.5) * 2 * Math.exp(-t * 10) * 0.3;
            }
          }
          return b;
        }
        play(name, vol = 1) {
          if (!this.isInitialized || !GameState.settings.soundEnabled) return;
          const buf = this.sounds[name];
          if (!buf) return;
          try {
            const src = this.audioContext.createBufferSource();
            const g = this.audioContext.createGain();
            g.gain.value = vol;
            src.buffer = buf;
            src.connect(g);
            g.connect(this.masterGain);
            src.start();
          } catch (e) {}
        }
        vibrate(ms = 40) {
          if (!GameState.settings.vibrationEnabled) return;
          if ('vibrate' in navigator) {
            try {
              navigator.vibrate(ms);
            } catch (e) {}
          }
        }
      }

      // ===== 儲存管理 =====
      class StorageManager {
        constructor() {
          this.KEY = 'eliteTapBattle_FineLightning_PWA_v3';
          this.loadSettings();
        }
        loadSettings() {
          try {
            const d = JSON.parse(localStorage.getItem(this.KEY) || '{}');
            if (d.settings) Object.assign(GameState.settings, d.settings);
          } catch (_) {}
        }
        saveSettings() {
          const d = this.loadData();
          d.settings = { ...GameState.settings };
          this.saveData(d);
        }
        saveScore(mode, score, score2 = null, maxTPS = null) {
          const d = this.loadData();
          const rec = {
            mode,
            score,
            score2,
            maxTPS,
            duration: GameState.settings.gameDuration,
            date: new Date().toISOString(),
            ts: Date.now(),
          };
          d.leaderboard = d.leaderboard || [];
          d.leaderboard.push(rec);
          d.leaderboard.sort((a, b) => b.score - a.score);
          d.leaderboard = d.leaderboard.slice(0, 100); // 增加到100條記錄
          this.saveData(d);
        }
        getLeaderboard(mode = null, duration = null, limit = 10) {
          const d = this.loadData();
          let r = d.leaderboard || [];
          if (mode) r = r.filter(x => x.mode === mode);
          if (duration && duration !== 'all') r = r.filter(x => x.duration === parseInt(duration));
          return r.slice(0, limit);
        }
        clearData() {
          if (confirm('確定要清除所有遊戲記錄嗎？')) {
            localStorage.removeItem(this.KEY);
            alert('記錄已清除！');
          }
        }
        loadData() {
          try {
            return JSON.parse(localStorage.getItem(this.KEY) || '{}');
          } catch (_) {
            return {};
          }
        }
        saveData(d) {
          try {
            localStorage.setItem(this.KEY, JSON.stringify(d));
          } catch (_) {
            alert('儲存空間已滿，請清除舊記錄！');
          }
        }
      }

      // ===== UI 管理 =====
      class AdvancedUIManager {
        constructor() {
          this.encouragementTimeout = null;
          document.getElementById('startSingleBtn').addEventListener('click', async () => {
            await this.initAudio();
            gameEngine.startSinglePlayer();
          });
          document.getElementById('startDualBtn').addEventListener('click', async () => {
            await this.initAudio();
            gameEngine.startDualPlayer();
          });
          document.getElementById('leaderboardBtn').addEventListener('click', () => {
            this.currentLeaderboardMode = 'single';
            this.currentLeaderboardPage = 1;
            this.currentLeaderboardDuration = 'all';
            this.updateLeaderboard('single', 1, 'all');
            this.showModal('leaderboardModal');
            this.updateLeaderboardTabs();
            this.updateTimeTabsUI();
          });
          document.getElementById('settingsBtn').addEventListener('click', () => {
            this.showSettings();
          });
          document.getElementById('gameInfoBtn').addEventListener('click', () => {
            this.showModal('gameInfoModal');
          });

          document
            .getElementById('gameExit')
            .addEventListener('click', () => gameEngine.exitGame());
          document.getElementById('playAgainBtn').addEventListener('click', () => {
            this.hideModal('resultModal');
            if (GameState.mode === 'single') gameEngine.startSinglePlayer();
            else gameEngine.startDualPlayer();
          });
          document.getElementById('backToMenuBtn').addEventListener('click', () => {
            this.hideModal('resultModal');
            gameEngine.exitGame();
          });

          // 雙人模式按鈕事件監聽器
          document.getElementById('playAgainDualBtn').addEventListener('click', () => {
            this.hideModal('resultModal');
            gameEngine.startDualPlayer();
          });
          document.getElementById('backToMenuDualBtn').addEventListener('click', () => {
            this.hideModal('resultModal');
            gameEngine.exitGame();
          });

          document
            .getElementById('closeLeaderboardBtn')
            .addEventListener('click', () => this.hideModal('leaderboardModal'));
          document.getElementById('clearLeaderboardBtn').addEventListener('click', () => {
            if (confirm('確定要清除所有記錄嗎？此操作無法復原。')) {
              storageManager.clearData();
              this.updateLeaderboard(
                this.currentLeaderboardMode || 'single',
                1,
                this.currentLeaderboardDuration || 'all'
              );
            }
          });

          // 排行榜分頁和標籤事件
          this.setupLeaderboardEvents();

          document.getElementById('closeSettingsBtn').addEventListener('click', () => {
            this.saveSettings();
            this.hideModal('settingsModal');
            sendSettingsToWorker();
          });
          document.getElementById('closeGameInfoBtn').addEventListener('click', () => {
            this.hideModal('gameInfoModal');
          });

          document.addEventListener('keydown', e => {
            if (e.code === 'Escape' && GameState.isPlaying) gameEngine.exitGame();
          });

          this.loadSettingsUI();
          this.setupPWAInstallBanner();
        }
        async initAudio() {
          if (!audioManager.isInitialized) await audioManager.init();
        }
        showGameScreen(mode) {
          document.getElementById('menuScreen').classList.add('hidden');
          const gs = document.getElementById('gameScreen');
          gs.classList.add('active');
          gs.setAttribute('aria-hidden', 'false');
          if (mode === 'single') {
            document.getElementById('singlePlayerArea').style.display = 'flex';
            document.getElementById('dualPlayerArea').style.display = 'none';
            // 重置鼓勵文字
            const encouragementEl = document.getElementById('encouragementText');
            if (encouragementEl) {
              encouragementEl.textContent = '點擊開始你的挑戰！';
            }
          } else {
            document.getElementById('singlePlayerArea').style.display = 'none';
            document.getElementById('dualPlayerArea').style.display = 'grid';
          }
        }
        showMenuScreen() {
          document.getElementById('menuScreen').classList.remove('hidden');
          const gs = document.getElementById('gameScreen');
          gs.classList.remove('active');
          gs.setAttribute('aria-hidden', 'true');
        }
        updateGameUI() {
          document.getElementById('gameMode').textContent =
            GameState.mode === 'single' ? '單人挑戰' : '雙人對戰';
          document.getElementById('hudModeP1').textContent = '雙人對戰';
          document.getElementById('hudModeP2').textContent = '雙人對戰';
          this.applyTpsToggle();
        }
        updateScoreDisplay() {
          if (GameState.mode === 'single') {
            document.getElementById('singleScore').textContent = GameState.scores.single;
          } else {
            document.getElementById('player1Score').textContent = GameState.scores.player1;
            document.getElementById('player2Score').textContent = GameState.scores.player2;
          }
        }
        animateScore(playerId) {
          const el = document.getElementById(`${playerId}Score`);
          if (!el) return;
          el.style.animation = 'none';
          el.offsetHeight;
          el.style.animation = 'pulse .28s ease-in-out alternate';
        }
        updateTimer() {
          const t = Math.ceil(GameState.timeLeft);
          const tEl = document.getElementById('gameTimer');
          tEl.textContent = t;
          if (GameState.timeLeft <= 5 && GameState.timeLeft > 0) {
            tEl.style.color = 'var(--sky-600)';
            tEl.style.animation = 'pulse .5s ease-in-out infinite alternate';
          } else {
            tEl.style.color = 'var(--primary)';
            tEl.style.animation = '';
          }
          document.getElementById('hudTimerP1').textContent = t;
          document.getElementById('hudTimerP2').textContent = t;
          this.updateTpsHUD();
        }

        updateEncouragementText(currentTPS) {
          const textEl = document.getElementById('encouragementText');
          if (!textEl) return;

          const message = getEncouragementMessage(currentTPS);

          // 只有在文字改變時才更新，並顯示至少1秒
          if (textEl.textContent !== message) {
            textEl.textContent = message;

            // 添加閃爍效果
            textEl.style.animation = 'none';
            textEl.offsetHeight; // 強制重繪
            textEl.style.animation = 'pulse 0.5s ease-in-out';

            // 確保顯示至少1秒
            clearTimeout(this.encouragementTimeout);
            this.encouragementTimeout = setTimeout(() => {
              // 1秒後可以更新為新的文字
            }, 1000);
          }
        }
        updateTpsHUD() {
          if (!GameState.settings.showTps) return;
          const p1Wrapper = document.getElementById('hudTpsP1Wrapper'),
            p2Wrapper = document.getElementById('hudTpsP2Wrapper'),
            headerTps = document.getElementById('headerTps');

          if (GameState.mode === 'single') {
            const tps = GameState.tpsEMA.single;
            const tpsDisplay = Math.min(99999, Math.round(tps * 10) / 10);
            const valueEl = headerTps.querySelector('.hud-tps-value');
            valueEl.textContent = tpsDisplay;

            // 添加高 TPS 漸層文字效果
            if (tps > 30) {
              valueEl.classList.add('high-tps');
            } else {
              valueEl.classList.remove('high-tps');
            }

            // 30TPS以上觸發RGB動畫效果，並至少持續顯示1秒
            if (tps > 30) {
              headerTps.classList.add('ultra-speed');
              // 設置最短顯示時間1秒
              if (GameState.ultraSpeedTimeout) {
                clearTimeout(GameState.ultraSpeedTimeout);
              }
              GameState.ultraSpeedTimeout = setTimeout(() => {
                if (GameState.tpsEMA.single <= 30) {
                  headerTps.classList.remove('ultra-speed');
                }
              }, 1000);
            } else if (!GameState.ultraSpeedTimeout) {
              headerTps.classList.remove('ultra-speed');
            }
          } else {
            const tps1 = GameState.tpsEMA.player1;
            const tps2 = GameState.tpsEMA.player2;
            const tps1Display = Math.min(99999, Math.round(tps1 * 10) / 10);
            const tps2Display = Math.min(99999, Math.round(tps2 * 10) / 10);

            const p1 = document.getElementById('hudTpsP1');
            const p2 = document.getElementById('hudTpsP2');
            const value1El = p1.querySelector('.hud-tps-value');
            const value2El = p2.querySelector('.hud-tps-value');

            value1El.textContent = tps1Display;
            value2El.textContent = tps2Display;

            // Player 1 - 30TPS以上觸發RGB動畫效果，並至少持續顯示1秒
            if (tps1 > 30) {
              p1Wrapper.classList.add('ultra-speed');
              if (GameState.ultraSpeedTimeout1) {
                clearTimeout(GameState.ultraSpeedTimeout1);
              }
              GameState.ultraSpeedTimeout1 = setTimeout(() => {
                if (GameState.tpsEMA.player1 <= 30) {
                  p1Wrapper.classList.remove('ultra-speed');
                }
              }, 1000);
            } else if (!GameState.ultraSpeedTimeout1) {
              p1Wrapper.classList.remove('ultra-speed');
            }

            // Player 2 - 30TPS以上觸發RGB動畫效果，並至少持續顯示1秒
            if (tps2 > 30) {
              p2Wrapper.classList.add('ultra-speed');
              if (GameState.ultraSpeedTimeout2) {
                clearTimeout(GameState.ultraSpeedTimeout2);
              }
              GameState.ultraSpeedTimeout2 = setTimeout(() => {
                if (GameState.tpsEMA.player2 <= 30) {
                  p2Wrapper.classList.remove('ultra-speed');
                }
              }, 1000);
            } else if (!GameState.ultraSpeedTimeout2) {
              p2Wrapper.classList.remove('ultra-speed');
            }
          }
        }
        applyTpsToggle() {
          const el1 = document.getElementById('hudTpsP1Wrapper'),
            el2 = document.getElementById('hudTpsP2Wrapper'),
            headerTps = document.getElementById('headerTps');
          if (GameState.settings.showTps) {
            if (el1) el1.classList.add('show');
            if (el2) el2.classList.add('show');
            if (headerTps) headerTps.style.display = 'flex';
          } else {
            if (el1) el1.classList.remove('show');
            if (el2) el2.classList.remove('show');
            if (headerTps) headerTps.style.display = 'none';
          }
        }
        showResult(r) {
          const modal = document.getElementById('resultModal');
          const singleResult = document.getElementById('singleResult');
          const dualResult = document.getElementById('dualResult');

          if (GameState.mode === 'single') {
            // 顯示單人模式結果
            singleResult.style.display = 'block';
            dualResult.style.display = 'none';

            const title = document.getElementById('resultTitle');
            const score = document.getElementById('resultScore');
            const tpsDiv = document.getElementById('resultTPS');
            const badge = document.getElementById('achievementBadge');

            title.textContent = '單人挑戰完成！';
            score.textContent = r.score;
            tpsDiv.textContent = (Math.round(GameState.maxTPS.single * 10) / 10).toFixed(1);

            // 根據成績設置成就徽章
            if (GameState.maxTPS.single >= 50) {
              badge.innerHTML =
                '<div class="badge-icon"><span class="material-symbols-rounded">rocket_launch</span></div><div class="badge-text">超音速大師</div>';
            } else if (GameState.maxTPS.single >= 30) {
              badge.innerHTML =
                '<div class="badge-icon"><span class="material-symbols-rounded">bolt</span></div><div class="badge-text">閃電快手</div>';
            } else if (GameState.maxTPS.single >= 20) {
              badge.innerHTML =
                '<div class="badge-icon"><span class="material-symbols-rounded">local_fire_department</span></div><div class="badge-text">點擊高手</div>';
            } else {
              badge.innerHTML =
                '<div class="badge-icon"><span class="material-symbols-rounded">star</span></div><div class="badge-text">初露鋒芒</div>';
            }
          } else {
            // 顯示雙人模式結果
            singleResult.style.display = 'none';
            dualResult.style.display = 'block';

            const dualTitle = document.getElementById('dualResultTitle');
            const dualSubtitle = document.getElementById('dualResultSubtitle');
            const winnerCrown = document.getElementById('winnerCrown');

            const player1Result = document.getElementById('player1Result');
            const player2Result = document.getElementById('player2Result');
            const player1Medal = document.getElementById('player1Medal');
            const player2Medal = document.getElementById('player2Medal');

            const player1ScoreEl = document.getElementById('player1ResultScore');
            const player2ScoreEl = document.getElementById('player2ResultScore');
            const player1TPSEl = document.getElementById('player1ResultTPS');
            const player2TPSEl = document.getElementById('player2ResultTPS');

            const dualBadge = document.getElementById('dualAchievementBadge');

            // 設置分數和TPS
            player1ScoreEl.textContent = r.score;
            player2ScoreEl.textContent = r.score2;
            player1TPSEl.textContent = (Math.round(GameState.maxTPS.player1 * 10) / 10).toFixed(1);
            player2TPSEl.textContent = (Math.round(GameState.maxTPS.player2 * 10) / 10).toFixed(1);

            // 重置樣式
            player1Result.classList.remove('winner');
            player2Result.classList.remove('winner');

            // 設置獲勝者
            if (r.winner) {
              dualTitle.textContent = `${r.winner === 'player1' ? '玩家 1' : '玩家 2'} 獲勝！`;
              dualSubtitle.textContent = '恭喜獲得勝利！';
              winnerCrown.style.display = 'block';

              if (r.winner === 'player1') {
                player1Result.classList.add('winner');
                player1Medal.innerHTML =
                  '<div class="medal-icon"><span class="material-symbols-rounded" style="font-size: 48px; color: #ffd700;">military_tech</span></div>';
                player2Medal.innerHTML =
                  '<div class="medal-icon"><span class="material-symbols-rounded" style="font-size: 48px; color: #c0c0c0;">military_tech</span></div>';
              } else {
                player2Result.classList.add('winner');
                player1Medal.innerHTML =
                  '<div class="medal-icon"><span class="material-symbols-rounded" style="font-size: 48px; color: #c0c0c0;">military_tech</span></div>';
                player2Medal.innerHTML =
                  '<div class="medal-icon"><span class="material-symbols-rounded" style="font-size: 48px; color: #ffd700;">military_tech</span></div>';
              }
            } else {
              dualTitle.textContent = '平手對決！';
              dualSubtitle.textContent = '勢均力敵的較量！';
              winnerCrown.style.display = 'none';
              player1Medal.innerHTML =
                '<div class="medal-icon"><span class="material-symbols-rounded" style="font-size: 48px; color: var(--accent);">handshake</span></div>';
              player2Medal.innerHTML =
                '<div class="medal-icon"><span class="material-symbols-rounded" style="font-size: 48px; color: var(--accent);">handshake</span></div>';
            }

            // 設置成就徽章
            const maxTPS = Math.max(GameState.maxTPS.player1, GameState.maxTPS.player2);
            if (maxTPS >= 50) {
              dualBadge.innerHTML =
                '<div class="badge-icon"><span class="material-symbols-rounded">crown</span></div><div class="badge-text">對戰王者</div>';
            } else if (maxTPS >= 30) {
              dualBadge.innerHTML =
                '<div class="badge-icon"><span class="material-symbols-rounded">swords</span></div><div class="badge-text">激戰高手</div>';
            } else if (maxTPS >= 20) {
              dualBadge.innerHTML =
                '<div class="badge-icon"><span class="material-symbols-rounded">local_fire_department</span></div><div class="badge-text">點擊達人</div>';
            } else {
              dualBadge.innerHTML =
                '<div class="badge-icon"><span class="material-symbols-rounded">handshake</span></div><div class="badge-text">友誼第一</div>';
            }
          }

          modal.classList.add('show');
          modal.setAttribute('aria-hidden', 'false');
        }
        showModal(id) {
          const m = document.getElementById(id);
          m.classList.add('show');
          m.setAttribute('aria-hidden', 'false');
        }
        hideModal(id) {
          const m = document.getElementById(id);
          m.classList.remove('show');
          m.setAttribute('aria-hidden', 'true');
        }
        showSettings() {
          document.getElementById('soundEnabled').checked = GameState.settings.soundEnabled;
          document.getElementById('vibrationEnabled').checked = GameState.settings.vibrationEnabled;
          document.getElementById('gameDuration').value = GameState.settings.gameDuration;
          document.getElementById('rippleEnabled').checked = GameState.settings.rippleEnabled;
          document.getElementById('lightningEnabled').checked = GameState.settings.lightningEnabled;
          document.getElementById('showTps').checked = GameState.settings.showTps;
          this.showModal('settingsModal');
        }
        saveSettings() {
          GameState.settings.soundEnabled = document.getElementById('soundEnabled').checked;
          GameState.settings.vibrationEnabled = document.getElementById('vibrationEnabled').checked;
          GameState.settings.gameDuration = parseInt(
            document.getElementById('gameDuration').value,
            10
          );
          GameState.settings.rippleEnabled = document.getElementById('rippleEnabled').checked;
          GameState.settings.lightningEnabled = document.getElementById('lightningEnabled').checked;
          GameState.settings.showTps = document.getElementById('showTps').checked;
          storageManager.saveSettings();
          this.applyTpsToggle();
          sendSettingsToWorker();
        }
        loadSettingsUI() {
          document.getElementById('soundEnabled').checked = GameState.settings.soundEnabled;
          document.getElementById('vibrationEnabled').checked = GameState.settings.vibrationEnabled;
          document.getElementById('gameDuration').value = GameState.settings.gameDuration;
          document.getElementById('rippleEnabled').checked = GameState.settings.rippleEnabled;
          document.getElementById('lightningEnabled').checked = GameState.settings.lightningEnabled;
          document.getElementById('showTps').checked = GameState.settings.showTps;
          this.applyTpsToggle();
        }
        updateLeaderboard(mode = 'single', page = 1, duration = 'all') {
          const itemsPerPage = 8;
          const list = document.getElementById('leaderboardList');
          const currentPageEl = document.getElementById('currentPage');
          const totalPagesEl = document.getElementById('totalPages');
          const prevBtn = document.getElementById('prevPageBtn');
          const nextBtn = document.getElementById('nextPageBtn');

          // 獲取指定模式和時間的記錄
          const allRecords = storageManager.getLeaderboard(mode, duration, 100);
          const totalPages = Math.max(1, Math.ceil(allRecords.length / itemsPerPage));
          const startIndex = (page - 1) * itemsPerPage;
          const records = allRecords.slice(startIndex, startIndex + itemsPerPage);

          // 更新分頁信息
          currentPageEl.textContent = page;
          totalPagesEl.textContent = totalPages;
          prevBtn.disabled = page <= 1;
          nextBtn.disabled = page >= totalPages;

          // 渲染記錄列表
          if (records.length === 0) {
            list.innerHTML = `
              <div class="empty-leaderboard">
                <div class="empty-icon">
                  <span class="material-symbols-rounded" style="font-size: 48px; opacity: 0.5;">trophy</span>
                </div>
                <div class="empty-text">暫無記錄</div>
                <div class="empty-hint">開始遊戲來創造你的第一個記錄吧！</div>
              </div>
            `;
            return;
          }

          list.innerHTML = records
            .map((record, index) => {
              const globalRank = startIndex + index + 1;
              const date = new Date(record.date).toLocaleDateString('zh-TW', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
              });

              let rankClass = 'rank-other';
              if (globalRank === 1) rankClass = 'rank-1';
              else if (globalRank === 2) rankClass = 'rank-2';
              else if (globalRank === 3) rankClass = 'rank-3';

              const scoreText =
                record.score2 != null ? `${record.score} : ${record.score2}` : record.score;

              const tpsText = record.maxTPS ? `最高 TPS: ${record.maxTPS}` : '';

              return `
              <div class="leaderboard-item">
                <div class="rank-badge ${rankClass}">${globalRank}</div>
                <div class="player-info">
                  <div class="player-name">${
                    record.mode === 'single' ? '單人挑戰' : '雙人對戰'
                  }${record.duration ? ` (${record.duration}秒)` : ''}</div>
                  <div class="player-date">${date}</div>
                </div>
                <div class="score-info">
                  <div class="score-value">${scoreText}</div>
                  ${tpsText ? `<div class="tps-info">${tpsText}</div>` : ''}
                </div>
              </div>
            `;
            })
            .join('');

          // 存儲當前狀態
          this.currentLeaderboardMode = mode;
          this.currentLeaderboardPage = page;
          this.currentLeaderboardDuration = duration;
        }

        setupLeaderboardEvents() {
          // 模式標籤切換
          document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
              const mode = btn.dataset.mode;
              this.currentLeaderboardMode = mode;
              this.currentLeaderboardPage = 1;
              this.updateLeaderboard(mode, 1, this.currentLeaderboardDuration || 'all');
              this.updateLeaderboardTabs();
            });
          });

          // 時間標籤切換
          document.querySelectorAll('.time-tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
              const duration = btn.dataset.time;
              this.currentLeaderboardDuration = duration;
              this.currentLeaderboardPage = 1;
              this.updateLeaderboard(this.currentLeaderboardMode || 'single', 1, duration);
              this.updateTimeTabsUI();
            });
          });

          // 分頁按鈕
          document.getElementById('prevPageBtn').addEventListener('click', () => {
            if (this.currentLeaderboardPage > 1) {
              this.currentLeaderboardPage--;
              this.updateLeaderboard(
                this.currentLeaderboardMode,
                this.currentLeaderboardPage,
                this.currentLeaderboardDuration
              );
            }
          });

          document.getElementById('nextPageBtn').addEventListener('click', () => {
            this.currentLeaderboardPage++;
            this.updateLeaderboard(
              this.currentLeaderboardMode,
              this.currentLeaderboardPage,
              this.currentLeaderboardDuration
            );
          });
        }

        updateLeaderboardTabs() {
          document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === this.currentLeaderboardMode);
          });
        }

        updateTimeTabsUI() {
          document.querySelectorAll('.time-tab-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.time === this.currentLeaderboardDuration);
          });
        }

        // PWA 安裝提示
        setupPWAInstallBanner() {
          const banner = document.getElementById('installBanner');
          const title = document.getElementById('installTitle');
          const hint = document.getElementById('installHint');
          const btnInstall = document.getElementById('installAction');
          const btnDismiss = document.getElementById('installDismiss');
          const DISMISS_KEY = 'etb_install_dismiss_v1';
          if (localStorage.getItem(DISMISS_KEY) === '1') return;
          const isStandalone =
            window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;
          if (isStandalone) return;
          const isiOS = /iphone|ipad|ipod/i.test(navigator.userAgent);
          let deferredPrompt = null;
          if (!isiOS) {
            window.addEventListener('beforeinstallprompt', e => {
              e.preventDefault();
              deferredPrompt = e;
              title.textContent = '安裝 Bunny Click';
              hint.textContent = '支援離線、啟動更快、全螢幕體驗';
              btnInstall.textContent = '安裝';
              banner.classList.add('show');
              document.documentElement.classList.add('has-install-banner');
            });
            btnInstall.onclick = async () => {
              if (!deferredPrompt) return;
              deferredPrompt.prompt();
              const { outcome } = await deferredPrompt.userChoice;
              if (outcome !== 'dismissed') banner.classList.remove('show');
              deferredPrompt = null;
            };
          } else {
            title.textContent = '加入主畫面（iOS）';
            hint.innerHTML = '在 Safari 按 <b>分享</b> → <b>加入到主畫面</b>，即可離線全螢幕遊玩';
            btnInstall.textContent = '知道了';
            banner.classList.add('show');
            document.documentElement.classList.add('has-install-banner');
            btnInstall.onclick = () => {
              banner.classList.remove('show');
              document.documentElement.classList.remove('has-install-banner');
            };
          }
          btnDismiss.onclick = () => {
            localStorage.setItem(DISMISS_KEY, '1');
            banner.classList.remove('show');
            document.documentElement.classList.remove('has-install-banner');
          };
        }
      }

      // ===== 輸入管理（批次丟到 Worker）=====
      class AdvancedInputManager {
        constructor(gameEngine) {
          this.gameEngine = gameEngine;
          const area = document.getElementById('gameArea');
          area.addEventListener('pointerdown', this.onDown.bind(this), {
            passive: false,
          });
          area.addEventListener('pointermove', this.onMove.bind(this), {
            passive: false,
          });
          area.addEventListener('pointerup', this.onUp.bind(this), {
            passive: false,
          });
          area.addEventListener('pointercancel', this.onUp.bind(this), {
            passive: false,
          });
          area.addEventListener('contextmenu', e => e.preventDefault());
          area.addEventListener('dblclick', e => e.preventDefault());

          const pump = () => {
            if (fxWorker && GameState.tapQueues.length) {
              fxWorker.postMessage({
                type: 'batch',
                taps: GameState.tapQueues.splice(0, GameState.tapQueues.length),
              });
            }
            requestAnimationFrame(pump);
          };
          requestAnimationFrame(pump);
        }
        onDown(e) {
          if (!GameState.isPlaying) return;
          if (performance.now() < GameState.inputLockUntil) return;
          e.preventDefault();
          const rect = e.currentTarget.getBoundingClientRect();
          const x = e.clientX - rect.left,
            y = e.clientY - rect.top;
          const id = e.pointerId;
          e.currentTarget.setPointerCapture(id);

          let playerId;
          if (GameState.mode === 'single') {
            playerId = 'single';
          } else {
            playerId = y < rect.height / 2 ? 'player1' : 'player2';
          }

          GameState.pointers.set(id, { playerId, element: e.currentTarget });

          const now = performance.now();

          // 記錄點擊時間戳用於 TPS 計算
          GameState.tapTimestamps[playerId].push(now);

          // 計算當前真實 TPS
          const currentTPS = calculateRealTPS(playerId);
          GameState.tpsEMA[playerId] = currentTPS;

          const tier = tpsToLevel(currentTPS);
          GameState.lastTapTime[playerId] = now;

          // 單人模式第一次點擊時開始計時
          if (GameState.mode === 'single' && !GameState.hasStarted) {
            GameState.hasStarted = true;
            this.gameEngine.startTime = now; // 重設開始時間
            console.log('🎮 遊戲計時開始！');
          }

          GameState.activePointers.set(id, { x, y, playerId, tier });
          GameState.scores[playerId]++;
          uiManager.updateScoreDisplay();
          uiManager.animateScore(playerId);

          // 單人模式更新鼓勵文字
          if (GameState.mode === 'single') {
            uiManager.updateEncouragementText(currentTPS);
          }

          // 水波紋觸發條件：每秒點擊 > 20 且每 3 次觸發一次
          const rippleOk = currentTPS > 20 && GameState.scores[playerId] % 3 === 0;
          // 超高速閃電效果：TPS > 30 (與顯示邏輯保持一致)
          const ultraSpeed = currentTPS > 30;

          GameState.tapQueues.push({
            x,
            y,
            ts: now,
            tier,
            playerId,
            mode: GameState.mode,
            rippleEligible: rippleOk,
            ultraSpeed: ultraSpeed,
          });

          audioManager.play('tap', 0.5);
          audioManager.vibrate();
          if (GameState.mode === 'dual') {
            const zone = document.querySelector(`.player-zone.${playerId}`);
            if (zone) zone.classList.add('active');
          }
        }
        onMove(e) {
          if (!GameState.isPlaying) return;
          e.preventDefault();
          const rect = e.currentTarget.getBoundingClientRect();
          const x = e.clientX - rect.left,
            y = e.clientY - rect.top;
          const p = GameState.activePointers.get(e.pointerId);
          if (p) {
            p.x = x;
            p.y = y;
          }
        }
        onUp(e) {
          const meta = GameState.pointers.get(e.pointerId);
          if (meta) {
            try {
              meta.element.releasePointerCapture(e.pointerId);
            } catch (_) {}
            if (GameState.mode === 'dual') {
              const zone = document.querySelector(`.player-zone.${meta.playerId}`);
              if (zone) zone.classList.remove('active');
            }
          }
          GameState.pointers.delete(e.pointerId);
          GameState.activePointers.delete(e.pointerId);
        }
      }

      // ===== 遊戲引擎 =====
      class AdvancedGameEngine {
        constructor() {
          this.animationFrame = null;
          this.startTime = 0;
          this.lastCountdownSecond = null;
          this.isFullscreen = false;
        }
        async startSinglePlayer() {
          await this.enterFullscreen();
          this.startGame('single', 0);
        }
        async startDualPlayer() {
          await this.enterFullscreen();
          this.startGame('dual', 1000);
        } // 開頭延遲 1 秒

        async enterFullscreen() {
          // 只在移動設備時自動全螢幕
          if (!this.isMobileDevice()) {
            return;
          }

          try {
            const el = document.documentElement;
            if (el.requestFullscreen) await el.requestFullscreen();
            else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
            this.isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
          } catch (_) {}
        }

        isMobileDevice() {
          // 檢測是否為移動設備（手機或平板）
          const userAgent = navigator.userAgent.toLowerCase();
          const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(
            userAgent
          );
          const isTablet = /ipad|android(?!.*mobile)/i.test(userAgent);
          const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
          const isSmallScreen = window.innerWidth <= 1024; // 平板尺寸以下

          return isMobile || isTablet || (hasTouchScreen && isSmallScreen);
        }
        async exitFullscreen() {
          const doc = document;
          const fsEl = doc.fullscreenElement || doc.webkitFullscreenElement;
          if (!fsEl) {
            this.isFullscreen = false;
            return;
          }
          if (doc.visibilityState !== 'visible') {
            this.isFullscreen = false;
            return;
          }
          try {
            if (doc.exitFullscreen) {
              await doc.exitFullscreen().catch(() => {});
            } else if (doc.webkitExitFullscreen) {
              doc.webkitExitFullscreen();
            }
          } catch (_) {}
          this.isFullscreen = false;
        }

        startGame(mode, delayMs) {
          if (GameState.isPlaying) return;
          GameState.mode = mode;
          GameState.isPlaying = true;
          GameState.hasStarted = false; // 重置開始狀態
          GameState.timeLeft = GameState.settings.gameDuration;
          GameState.scores = { single: 0, player1: 0, player2: 0 };
          GameState.pointers.clear();
          GameState.activePointers.clear();
          GameState.lastTapTime = { single: 0, player1: 0, player2: 0 };
          GameState.tpsEMA = { single: 0, player1: 0, player2: 0 };
          GameState.tapTimestamps = { single: [], player1: [], player2: [] };
          GameState.maxTPS = { single: 0, player1: 0, player2: 0 };
          GameState.tapQueues.length = 0;

          // 啟動 TPS 更新定時器
          if (GameState.tpsUpdateInterval) {
            clearInterval(GameState.tpsUpdateInterval);
          }
          GameState.tpsUpdateInterval = setInterval(updateAllTPS, 100); // 每100ms更新一次
          GameState.inputLockUntil = performance.now() + (mode === 'dual' ? delayMs : 0);

          const appEl = document.getElementById('app');
          appEl.classList.toggle('single', mode === 'single');
          appEl.classList.toggle('dual', mode === 'dual');

          document.getElementById('gameHeader').classList.toggle('hidden', mode === 'dual');
          uiManager.showGameScreen(mode);
          uiManager.updateGameUI();
          uiManager.updateScoreDisplay();
          resizeFx();

          const syncActive = () => {
            if (!GameState.isPlaying) return;
            const arr = [];
            GameState.activePointers.forEach(v => arr.push(v));
            fxWorker && fxWorker.postMessage({ type: 'active', active: arr });
            setTimeout(syncActive, 66);
          };
          syncActive();

          this.startTime = performance.now() + delayMs;
          this.lastCountdownSecond = null;

          const loop = ts => {
            if (!GameState.isPlaying) return;

            // 在雙人模式中，於預定開始時間自動啟動計時（避免永不倒數）
            if (GameState.mode === 'dual' && !GameState.hasStarted && ts >= this.startTime) {
              GameState.hasStarted = true;
            }

            // 只有在遊戲已開始時才計時
            if (GameState.hasStarted) {
              const elapsed = (ts - this.startTime) / 1000;
              GameState.timeLeft = Math.max(
                0,
                GameState.settings.gameDuration - Math.max(0, elapsed)
              );
            }
            uiManager.updateTimer();

            if (GameState.timeLeft <= 3 && GameState.timeLeft > 0) {
              const secs = Math.ceil(GameState.timeLeft);
              if (secs !== this.lastCountdownSecond) {
                audioManager.play('countdown');
                this.lastCountdownSecond = secs;
              }
            }
            if (GameState.timeLeft <= 0) {
              this.endGame();
              return;
            }
            this.animationFrame = requestAnimationFrame(loop);
          };
          this.animationFrame = requestAnimationFrame(loop);
        }

        async endGame() {
          GameState.isPlaying = false;
          if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
            this.animationFrame = null;
          }
          // 清理 TPS 更新定時器
          if (GameState.tpsUpdateInterval) {
            clearInterval(GameState.tpsUpdateInterval);
            GameState.tpsUpdateInterval = null;
          }
          // 清理 Ultra Speed timeout
          if (GameState.ultraSpeedTimeout) {
            clearTimeout(GameState.ultraSpeedTimeout);
            GameState.ultraSpeedTimeout = null;
          }
          if (GameState.ultraSpeedTimeout1) {
            clearTimeout(GameState.ultraSpeedTimeout1);
            GameState.ultraSpeedTimeout1 = null;
          }
          if (GameState.ultraSpeedTimeout2) {
            clearTimeout(GameState.ultraSpeedTimeout2);
            GameState.ultraSpeedTimeout2 = null;
          }
          const result = this.calculateResult();
          await this.playFireworks(); // 播完煙火再顯示結果
          audioManager.play('victory', 0.9);
          uiManager.showResult(result);
        }

        calculateResult() {
          const r = { hasWinner: false, winner: null, score: 0, score2: 0 };
          if (GameState.mode === 'single') {
            r.score = GameState.scores.single;
            r.hasWinner = r.score > 0;
            storageManager.saveScore('single', r.score, null, GameState.maxTPS.single);
          } else {
            r.score = GameState.scores.player1;
            r.score2 = GameState.scores.player2;
            if (r.score > r.score2) {
              r.winner = 'player1';
              r.hasWinner = true;
            } else if (r.score2 > r.score) {
              r.winner = 'player2';
              r.hasWinner = true;
            }
            const maxTPS = Math.max(GameState.maxTPS.player1, GameState.maxTPS.player2);
            storageManager.saveScore(
              'dual',
              Math.max(r.score, r.score2),
              Math.min(r.score, r.score2),
              maxTPS
            );
          }
          return r;
        }

        playFireworks() {
          const container = document.getElementById('fireworkContainer');
          const colors = [
            '#f66fb9',
            '#ffb2dc',
            '#7ccaff',
            '#52b7ff',
            '#ffffff',
            '#ff6b6b',
            '#4ecdc4',
            '#45b7d1',
            '#96ceb4',
            '#ffeaa7',
            '#dda0dd',
            '#ff69b4',
            '#00ff00',
            '#ffd700',
            '#ff4500',
          ];
          const count = 24;
          const duration = 5500;

          return new Promise(resolve => {
            // Add victory screen flash effect
            document.getElementById('app').style.animation = 'victoryFlash 0.8s ease-out';

            for (let i = 0; i < count; i++) {
              setTimeout(
                () => {
                  const cx = Math.random() * window.innerWidth;
                  const cy = Math.random() * (window.innerHeight * 0.7) + window.innerHeight * 0.15;
                  const fireworkType = Math.random();

                  if (fireworkType < 0.3) {
                    // Large burst firework
                    this.createBurstFirework(container, cx, cy, colors, 18, 180);
                  } else if (fireworkType < 0.6) {
                    // Ring firework
                    this.createRingFirework(container, cx, cy, colors, 16, 150);
                  } else if (fireworkType < 0.85) {
                    // Spiral firework
                    this.createSpiralFirework(container, cx, cy, colors, 24, 200);
                  } else {
                    // Chain explosion
                    this.createChainFirework(container, cx, cy, colors, 12, 120);
                  }

                  // Enhanced audio with random pitch
                  audioManager.play('firework', 0.3 + Math.random() * 0.4);

                  // Random victory sound bursts
                  if (Math.random() < 0.3) {
                    setTimeout(() => audioManager.play('victory', 0.1), Math.random() * 300);
                  }
                },
                i * (duration / count) + Math.random() * 200
              );
            }

            // Grand finale
            setTimeout(() => {
              this.createGrandFinale(container, colors);
              audioManager.play('victory', 0.8);
            }, duration * 0.8);

            setTimeout(() => {
              container.innerHTML = '';
              document.getElementById('app').style.animation = '';
              resolve();
            }, duration + 800);
          });
        }

        createBurstFirework(container, cx, cy, colors, particles, maxDist) {
          for (let j = 0; j < particles; j++) {
            const dot = document.createElement('div');
            dot.className = 'firework';
            const c = colors[Math.floor(Math.random() * colors.length)];
            dot.style.background = `radial-gradient(circle, ${c}, transparent)`;
            dot.style.boxShadow = `0 0 20px ${c}, 0 0 40px ${c}`;
            dot.style.left = cx + 'px';
            dot.style.top = cy + 'px';
            dot.style.width = 4 + Math.random() * 6 + 'px';
            dot.style.height = dot.style.width;
            container.appendChild(dot);

            const ang = (j / particles) * Math.PI * 2 + Math.random() * 0.5;
            const dist = maxDist * (0.7 + Math.random() * 0.6);
            const dur = 1200 + Math.random() * 800;

            dot
              .animate(
                [
                  { transform: 'translate(0,0) scale(1)', opacity: 1 },
                  {
                    transform: `translate(${Math.cos(ang) * dist}px, ${
                      Math.sin(ang) * dist + Math.random() * 50
                    }px) scale(0)`,
                    opacity: 0,
                  },
                ],
                {
                  duration: dur,
                  easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
                }
              )
              .addEventListener('finish', () => dot.remove());
          }
        }

        createRingFirework(container, cx, cy, colors, particles, radius) {
          for (let j = 0; j < particles; j++) {
            const dot = document.createElement('div');
            dot.className = 'firework';
            const c = colors[Math.floor(Math.random() * colors.length)];
            dot.style.background = c;
            dot.style.boxShadow = `0 0 15px ${c}`;
            dot.style.left = cx + 'px';
            dot.style.top = cy + 'px';
            dot.style.width = '6px';
            dot.style.height = '6px';
            container.appendChild(dot);

            const ang = (j / particles) * Math.PI * 2;
            const dur = 1000 + Math.random() * 400;

            dot
              .animate(
                [
                  { transform: 'translate(0,0) scale(1)', opacity: 1 },
                  {
                    transform: `translate(${Math.cos(ang) * radius}px, ${
                      Math.sin(ang) * radius
                    }px) scale(0.3)`,
                    opacity: 0.8,
                    offset: 0.7,
                  },
                  {
                    transform: `translate(${Math.cos(ang) * radius * 1.2}px, ${
                      Math.sin(ang) * radius * 1.2
                    }px) scale(0)`,
                    opacity: 0,
                  },
                ],
                { duration: dur, easing: 'ease-out' }
              )
              .addEventListener('finish', () => dot.remove());
          }
        }

        createSpiralFirework(container, cx, cy, colors, particles, maxDist) {
          for (let j = 0; j < particles; j++) {
            const dot = document.createElement('div');
            dot.className = 'firework';
            const c = colors[Math.floor(Math.random() * colors.length)];
            dot.style.background = `linear-gradient(45deg, ${c}, transparent)`;
            dot.style.boxShadow = `0 0 12px ${c}`;
            dot.style.left = cx + 'px';
            dot.style.top = cy + 'px';
            dot.style.width = '3px';
            dot.style.height = '15px';
            dot.style.borderRadius = '50%';
            container.appendChild(dot);

            const spiral = j * 0.8;
            const dist = (j / particles) * maxDist;
            const dur = 1500 + Math.random() * 600;

            dot
              .animate(
                [
                  {
                    transform: 'translate(0,0) rotate(0deg) scale(1)',
                    opacity: 1,
                  },
                  {
                    transform: `translate(${Math.cos(spiral) * dist}px, ${
                      Math.sin(spiral) * dist
                    }px) rotate(${(spiral * 180) / Math.PI}deg) scale(0)`,
                    opacity: 0,
                  },
                ],
                { duration: dur, easing: 'ease-out' }
              )
              .addEventListener('finish', () => dot.remove());
          }
        }

        createChainFirework(container, cx, cy, colors, particles, dist) {
          for (let j = 0; j < particles; j++) {
            setTimeout(() => {
              const dot = document.createElement('div');
              dot.className = 'firework';
              const c = colors[Math.floor(Math.random() * colors.length)];
              dot.style.background = c;
              dot.style.boxShadow = `0 0 25px ${c}, 0 0 50px ${c}`;
              dot.style.left = cx + (Math.random() - 0.5) * 100 + 'px';
              dot.style.top = cy + (Math.random() - 0.5) * 100 + 'px';
              dot.style.width = '8px';
              dot.style.height = '8px';
              container.appendChild(dot);

              const ang = Math.random() * Math.PI * 2;
              const d = dist * (0.8 + Math.random() * 0.4);

              dot
                .animate(
                  [
                    { transform: 'translate(0,0) scale(1)', opacity: 1 },
                    {
                      transform: `translate(${Math.cos(ang) * d}px, ${
                        Math.sin(ang) * d
                      }px) scale(0)`,
                      opacity: 0,
                    },
                  ],
                  { duration: 800, easing: 'ease-out' }
                )
                .addEventListener('finish', () => dot.remove());
            }, j * 50);
          }
        }

        createGrandFinale(container, colors) {
          // Create multiple large bursts simultaneously
          for (let i = 0; i < 6; i++) {
            const cx = (window.innerWidth / 6) * (i + 0.5);
            const cy = window.innerHeight * (0.3 + Math.random() * 0.4);
            this.createBurstFirework(container, cx, cy, colors, 32, 250);

            setTimeout(() => {
              this.createRingFirework(container, cx, cy, colors, 24, 200);
            }, 300);
          }

          // Add confetti shower
          setTimeout(() => {
            for (let i = 0; i < 100; i++) {
              const confetti = document.createElement('div');
              confetti.style.position = 'absolute';
              confetti.style.width = '6px';
              confetti.style.height = '6px';
              confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
              confetti.style.left = Math.random() * window.innerWidth + 'px';
              confetti.style.top = '-10px';
              confetti.style.borderRadius = '2px';
              container.appendChild(confetti);

              confetti
                .animate(
                  [
                    { transform: 'translateY(0) rotate(0deg)', opacity: 1 },
                    {
                      transform: `translateY(${
                        window.innerHeight + 50
                      }px) rotate(${Math.random() * 720}deg)`,
                      opacity: 0,
                    },
                  ],
                  {
                    duration: 3000 + Math.random() * 2000,
                    easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
                  }
                )
                .addEventListener('finish', () => confetti.remove());
            }
          }, 600);
        }

        async exitGame() {
          GameState.isPlaying = false;
          if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
            this.animationFrame = null;
          }
          // 清理 TPS 更新定時器
          if (GameState.tpsUpdateInterval) {
            clearInterval(GameState.tpsUpdateInterval);
            GameState.tpsUpdateInterval = null;
          }
          // 清理 Ultra Speed timeout
          if (GameState.ultraSpeedTimeout) {
            clearTimeout(GameState.ultraSpeedTimeout);
            GameState.ultraSpeedTimeout = null;
          }
          if (GameState.ultraSpeedTimeout1) {
            clearTimeout(GameState.ultraSpeedTimeout1);
            GameState.ultraSpeedTimeout1 = null;
          }
          if (GameState.ultraSpeedTimeout2) {
            clearTimeout(GameState.ultraSpeedTimeout2);
            GameState.ultraSpeedTimeout2 = null;
          }
          await this.exitFullscreen();
          uiManager.showMenuScreen();
        }
      }

      // ===== 初始化 =====
      let audioManager, inputManager, gameEngine, storageManager, uiManager;

      // 暴露到全局作用域以便調試
      window.GameState = GameState;
      let isInitialized = false;

      document.addEventListener('DOMContentLoaded', () => {
        // 防止重複初始化
        if (isInitialized) {
          console.log('Game already initialized, skipping...');
          return;
        }

        console.log('Initializing Bunny Click...');

        try {
          // 檢查版本更新
          checkForUpdates();

          audioManager = new AdvancedAudioManager();
          storageManager = new StorageManager();
          gameEngine = new AdvancedGameEngine();
          uiManager = new AdvancedUIManager();
          inputManager = new AdvancedInputManager(gameEngine);
          setupWorker();

          // 更新版本號顯示
          updateVersionDisplay();

          // 暴露到全局作用域以便調試
          window.gameEngine = gameEngine;
          window.uiManager = uiManager;
          window.inputManager = inputManager;

          isInitialized = true;
          console.log('✅ Game initialization complete');
        } catch (error) {
          console.error('❌ Game initialization failed: [ERROR FILTERED]');
        }

        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('./sw.js').catch(() => {
            /* 靜默失敗 */
          });
        }

        if (
          'connection' in navigator &&
          navigator.connection &&
          navigator.connection.saveData === true
        ) {
          document.documentElement.classList.add('save-data');
        }

        // 字體載入檢測優化，避免首屏看到英文
        Promise.all([
          document.fonts.load('1em "Material Symbols Rounded"'),
          document.fonts.load('1em "Fredoka One"'),
        ])
          .then(() => {
            document.documentElement.classList.add('fonts-ready');
          })
          .catch(() => {
            // 如果載入失敗，1.5秒後顯示避免永久隱藏
            setTimeout(() => document.documentElement.classList.add('fonts-ready'), 1500);
          });
      });

      // 全螢幕事件：不要在這裡呼叫 exitGame() 以免遞迴
      document.addEventListener('fullscreenchange', () => {
        const isFs = !!(document.fullscreenElement || document.webkitFullscreenElement);
        gameEngine.isFullscreen = isFs;
        if (!isFs && GameState.isPlaying) {
          GameState.isPlaying = false;
          uiManager.showMenuScreen();
        }
      });

      // 禁用雙擊放大
      (function preventZoom() {
        let last = 0;
        document.addEventListener(
          'touchend',
          e => {
            const now = Date.now();
            if (now - last <= 300) {
              e.preventDefault();
            }
            last = now;
          },
          { passive: false }
        );
        ['gesturestart', 'gesturechange', 'gestureend'].forEach(evt =>
          document.addEventListener(evt, e => e.preventDefault())
        );
      })();